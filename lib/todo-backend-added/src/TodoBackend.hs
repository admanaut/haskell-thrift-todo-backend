{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module TodoBackend where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Todobackendadded_Types
import qualified TodoBackend_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data CreateTodo_args = CreateTodo_args  { createTodo_args_title :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateTodo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createTodo_args_title record  
instance QC.Arbitrary CreateTodo_args where 
  arbitrary = M.liftM CreateTodo_args (QC.arbitrary)
  shrink obj | obj == default_CreateTodo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateTodo_args{createTodo_args_title = createTodo_args_title obj} then P.Nothing else P.Just $ default_CreateTodo_args{createTodo_args_title = createTodo_args_title obj}
    ]
from_CreateTodo_args :: CreateTodo_args -> T.ThriftVal
from_CreateTodo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v16 -> P.Just (1, ("title",T.TString $ E.encodeUtf8 _v16))) $ createTodo_args_title record
  ]
write_CreateTodo_args :: T.Protocol p => p -> CreateTodo_args -> P.IO ()
write_CreateTodo_args oprot record = T.writeVal oprot $ from_CreateTodo_args record
encode_CreateTodo_args :: T.StatelessProtocol p => p -> CreateTodo_args -> LBS.ByteString
encode_CreateTodo_args oprot record = T.serializeVal oprot $ from_CreateTodo_args record
to_CreateTodo_args :: T.ThriftVal -> CreateTodo_args
to_CreateTodo_args (T.TStruct fields) = CreateTodo_args{
  createTodo_args_title = P.maybe (createTodo_args_title default_CreateTodo_args) (\(_,_val18) -> (case _val18 of {T.TString _val19 -> E.decodeUtf8 _val19; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateTodo_args _ = P.error "not a struct"
read_CreateTodo_args :: T.Protocol p => p -> P.IO CreateTodo_args
read_CreateTodo_args iprot = to_CreateTodo_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateTodo_args)
decode_CreateTodo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateTodo_args
decode_CreateTodo_args iprot bs = to_CreateTodo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateTodo_args) bs
typemap_CreateTodo_args :: T.TypeMap
typemap_CreateTodo_args = Map.fromList [(1,("title",T.T_STRING))]
default_CreateTodo_args :: CreateTodo_args
default_CreateTodo_args = CreateTodo_args{
  createTodo_args_title = ""}
data CreateTodo_result = CreateTodo_result  { createTodo_result_success :: Todo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateTodo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createTodo_result_success record  
instance QC.Arbitrary CreateTodo_result where 
  arbitrary = M.liftM CreateTodo_result (QC.arbitrary)
  shrink obj | obj == default_CreateTodo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateTodo_result{createTodo_result_success = createTodo_result_success obj} then P.Nothing else P.Just $ default_CreateTodo_result{createTodo_result_success = createTodo_result_success obj}
    ]
from_CreateTodo_result :: CreateTodo_result -> T.ThriftVal
from_CreateTodo_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v22 -> P.Just (0, ("success",from_Todo _v22))) $ createTodo_result_success record
  ]
write_CreateTodo_result :: T.Protocol p => p -> CreateTodo_result -> P.IO ()
write_CreateTodo_result oprot record = T.writeVal oprot $ from_CreateTodo_result record
encode_CreateTodo_result :: T.StatelessProtocol p => p -> CreateTodo_result -> LBS.ByteString
encode_CreateTodo_result oprot record = T.serializeVal oprot $ from_CreateTodo_result record
to_CreateTodo_result :: T.ThriftVal -> CreateTodo_result
to_CreateTodo_result (T.TStruct fields) = CreateTodo_result{
  createTodo_result_success = P.maybe (createTodo_result_success default_CreateTodo_result) (\(_,_val24) -> (case _val24 of {T.TStruct _val25 -> (to_Todo (T.TStruct _val25)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_CreateTodo_result _ = P.error "not a struct"
read_CreateTodo_result :: T.Protocol p => p -> P.IO CreateTodo_result
read_CreateTodo_result iprot = to_CreateTodo_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateTodo_result)
decode_CreateTodo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateTodo_result
decode_CreateTodo_result iprot bs = to_CreateTodo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateTodo_result) bs
typemap_CreateTodo_result :: T.TypeMap
typemap_CreateTodo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Todo)))]
default_CreateTodo_result :: CreateTodo_result
default_CreateTodo_result = CreateTodo_result{
  createTodo_result_success = default_Todo}
data GetTodo_args = GetTodo_args  { getTodo_args_id :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTodo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTodo_args_id record  
instance QC.Arbitrary GetTodo_args where 
  arbitrary = M.liftM GetTodo_args (QC.arbitrary)
  shrink obj | obj == default_GetTodo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTodo_args{getTodo_args_id = getTodo_args_id obj} then P.Nothing else P.Just $ default_GetTodo_args{getTodo_args_id = getTodo_args_id obj}
    ]
from_GetTodo_args :: GetTodo_args -> T.ThriftVal
from_GetTodo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v28 -> P.Just (1, ("id",T.TI32 _v28))) $ getTodo_args_id record
  ]
write_GetTodo_args :: T.Protocol p => p -> GetTodo_args -> P.IO ()
write_GetTodo_args oprot record = T.writeVal oprot $ from_GetTodo_args record
encode_GetTodo_args :: T.StatelessProtocol p => p -> GetTodo_args -> LBS.ByteString
encode_GetTodo_args oprot record = T.serializeVal oprot $ from_GetTodo_args record
to_GetTodo_args :: T.ThriftVal -> GetTodo_args
to_GetTodo_args (T.TStruct fields) = GetTodo_args{
  getTodo_args_id = P.maybe (getTodo_args_id default_GetTodo_args) (\(_,_val30) -> (case _val30 of {T.TI32 _val31 -> _val31; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetTodo_args _ = P.error "not a struct"
read_GetTodo_args :: T.Protocol p => p -> P.IO GetTodo_args
read_GetTodo_args iprot = to_GetTodo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetTodo_args)
decode_GetTodo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTodo_args
decode_GetTodo_args iprot bs = to_GetTodo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTodo_args) bs
typemap_GetTodo_args :: T.TypeMap
typemap_GetTodo_args = Map.fromList [(1,("id",T.T_I32))]
default_GetTodo_args :: GetTodo_args
default_GetTodo_args = GetTodo_args{
  getTodo_args_id = 0}
data GetTodo_result = GetTodo_result  { getTodo_result_success :: Todo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTodo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTodo_result_success record  
instance QC.Arbitrary GetTodo_result where 
  arbitrary = M.liftM GetTodo_result (QC.arbitrary)
  shrink obj | obj == default_GetTodo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTodo_result{getTodo_result_success = getTodo_result_success obj} then P.Nothing else P.Just $ default_GetTodo_result{getTodo_result_success = getTodo_result_success obj}
    ]
from_GetTodo_result :: GetTodo_result -> T.ThriftVal
from_GetTodo_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v34 -> P.Just (0, ("success",from_Todo _v34))) $ getTodo_result_success record
  ]
write_GetTodo_result :: T.Protocol p => p -> GetTodo_result -> P.IO ()
write_GetTodo_result oprot record = T.writeVal oprot $ from_GetTodo_result record
encode_GetTodo_result :: T.StatelessProtocol p => p -> GetTodo_result -> LBS.ByteString
encode_GetTodo_result oprot record = T.serializeVal oprot $ from_GetTodo_result record
to_GetTodo_result :: T.ThriftVal -> GetTodo_result
to_GetTodo_result (T.TStruct fields) = GetTodo_result{
  getTodo_result_success = P.maybe (getTodo_result_success default_GetTodo_result) (\(_,_val36) -> (case _val36 of {T.TStruct _val37 -> (to_Todo (T.TStruct _val37)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetTodo_result _ = P.error "not a struct"
read_GetTodo_result :: T.Protocol p => p -> P.IO GetTodo_result
read_GetTodo_result iprot = to_GetTodo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetTodo_result)
decode_GetTodo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTodo_result
decode_GetTodo_result iprot bs = to_GetTodo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTodo_result) bs
typemap_GetTodo_result :: T.TypeMap
typemap_GetTodo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Todo)))]
default_GetTodo_result :: GetTodo_result
default_GetTodo_result = GetTodo_result{
  getTodo_result_success = default_Todo}
data UpdateTodo_args = UpdateTodo_args  { updateTodo_args_todo :: Todo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateTodo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTodo_args_todo record  
instance QC.Arbitrary UpdateTodo_args where 
  arbitrary = M.liftM UpdateTodo_args (QC.arbitrary)
  shrink obj | obj == default_UpdateTodo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTodo_args{updateTodo_args_todo = updateTodo_args_todo obj} then P.Nothing else P.Just $ default_UpdateTodo_args{updateTodo_args_todo = updateTodo_args_todo obj}
    ]
from_UpdateTodo_args :: UpdateTodo_args -> T.ThriftVal
from_UpdateTodo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v40 -> P.Just (1, ("todo",from_Todo _v40))) $ updateTodo_args_todo record
  ]
write_UpdateTodo_args :: T.Protocol p => p -> UpdateTodo_args -> P.IO ()
write_UpdateTodo_args oprot record = T.writeVal oprot $ from_UpdateTodo_args record
encode_UpdateTodo_args :: T.StatelessProtocol p => p -> UpdateTodo_args -> LBS.ByteString
encode_UpdateTodo_args oprot record = T.serializeVal oprot $ from_UpdateTodo_args record
to_UpdateTodo_args :: T.ThriftVal -> UpdateTodo_args
to_UpdateTodo_args (T.TStruct fields) = UpdateTodo_args{
  updateTodo_args_todo = P.maybe (updateTodo_args_todo default_UpdateTodo_args) (\(_,_val42) -> (case _val42 of {T.TStruct _val43 -> (to_Todo (T.TStruct _val43)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateTodo_args _ = P.error "not a struct"
read_UpdateTodo_args :: T.Protocol p => p -> P.IO UpdateTodo_args
read_UpdateTodo_args iprot = to_UpdateTodo_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTodo_args)
decode_UpdateTodo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateTodo_args
decode_UpdateTodo_args iprot bs = to_UpdateTodo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTodo_args) bs
typemap_UpdateTodo_args :: T.TypeMap
typemap_UpdateTodo_args = Map.fromList [(1,("todo",(T.T_STRUCT typemap_Todo)))]
default_UpdateTodo_args :: UpdateTodo_args
default_UpdateTodo_args = UpdateTodo_args{
  updateTodo_args_todo = default_Todo}
data UpdateTodo_result = UpdateTodo_result  { updateTodo_result_success :: Todo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateTodo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTodo_result_success record  
instance QC.Arbitrary UpdateTodo_result where 
  arbitrary = M.liftM UpdateTodo_result (QC.arbitrary)
  shrink obj | obj == default_UpdateTodo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTodo_result{updateTodo_result_success = updateTodo_result_success obj} then P.Nothing else P.Just $ default_UpdateTodo_result{updateTodo_result_success = updateTodo_result_success obj}
    ]
from_UpdateTodo_result :: UpdateTodo_result -> T.ThriftVal
from_UpdateTodo_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v46 -> P.Just (0, ("success",from_Todo _v46))) $ updateTodo_result_success record
  ]
write_UpdateTodo_result :: T.Protocol p => p -> UpdateTodo_result -> P.IO ()
write_UpdateTodo_result oprot record = T.writeVal oprot $ from_UpdateTodo_result record
encode_UpdateTodo_result :: T.StatelessProtocol p => p -> UpdateTodo_result -> LBS.ByteString
encode_UpdateTodo_result oprot record = T.serializeVal oprot $ from_UpdateTodo_result record
to_UpdateTodo_result :: T.ThriftVal -> UpdateTodo_result
to_UpdateTodo_result (T.TStruct fields) = UpdateTodo_result{
  updateTodo_result_success = P.maybe (updateTodo_result_success default_UpdateTodo_result) (\(_,_val48) -> (case _val48 of {T.TStruct _val49 -> (to_Todo (T.TStruct _val49)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_UpdateTodo_result _ = P.error "not a struct"
read_UpdateTodo_result :: T.Protocol p => p -> P.IO UpdateTodo_result
read_UpdateTodo_result iprot = to_UpdateTodo_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTodo_result)
decode_UpdateTodo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateTodo_result
decode_UpdateTodo_result iprot bs = to_UpdateTodo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTodo_result) bs
typemap_UpdateTodo_result :: T.TypeMap
typemap_UpdateTodo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Todo)))]
default_UpdateTodo_result :: UpdateTodo_result
default_UpdateTodo_result = UpdateTodo_result{
  updateTodo_result_success = default_Todo}
data DeleteTodo_args = DeleteTodo_args  { deleteTodo_args_todo :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteTodo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteTodo_args_todo record  
instance QC.Arbitrary DeleteTodo_args where 
  arbitrary = M.liftM DeleteTodo_args (QC.arbitrary)
  shrink obj | obj == default_DeleteTodo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteTodo_args{deleteTodo_args_todo = deleteTodo_args_todo obj} then P.Nothing else P.Just $ default_DeleteTodo_args{deleteTodo_args_todo = deleteTodo_args_todo obj}
    ]
from_DeleteTodo_args :: DeleteTodo_args -> T.ThriftVal
from_DeleteTodo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v52 -> P.Just (1, ("todo",T.TI32 _v52))) $ deleteTodo_args_todo record
  ]
write_DeleteTodo_args :: T.Protocol p => p -> DeleteTodo_args -> P.IO ()
write_DeleteTodo_args oprot record = T.writeVal oprot $ from_DeleteTodo_args record
encode_DeleteTodo_args :: T.StatelessProtocol p => p -> DeleteTodo_args -> LBS.ByteString
encode_DeleteTodo_args oprot record = T.serializeVal oprot $ from_DeleteTodo_args record
to_DeleteTodo_args :: T.ThriftVal -> DeleteTodo_args
to_DeleteTodo_args (T.TStruct fields) = DeleteTodo_args{
  deleteTodo_args_todo = P.maybe (deleteTodo_args_todo default_DeleteTodo_args) (\(_,_val54) -> (case _val54 of {T.TI32 _val55 -> _val55; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteTodo_args _ = P.error "not a struct"
read_DeleteTodo_args :: T.Protocol p => p -> P.IO DeleteTodo_args
read_DeleteTodo_args iprot = to_DeleteTodo_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteTodo_args)
decode_DeleteTodo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteTodo_args
decode_DeleteTodo_args iprot bs = to_DeleteTodo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteTodo_args) bs
typemap_DeleteTodo_args :: T.TypeMap
typemap_DeleteTodo_args = Map.fromList [(1,("todo",T.T_I32))]
default_DeleteTodo_args :: DeleteTodo_args
default_DeleteTodo_args = DeleteTodo_args{
  deleteTodo_args_todo = 0}
data DeleteTodo_result = DeleteTodo_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteTodo_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DeleteTodo_result where 
  arbitrary = QC.elements [DeleteTodo_result]
from_DeleteTodo_result :: DeleteTodo_result -> T.ThriftVal
from_DeleteTodo_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DeleteTodo_result :: T.Protocol p => p -> DeleteTodo_result -> P.IO ()
write_DeleteTodo_result oprot record = T.writeVal oprot $ from_DeleteTodo_result record
encode_DeleteTodo_result :: T.StatelessProtocol p => p -> DeleteTodo_result -> LBS.ByteString
encode_DeleteTodo_result oprot record = T.serializeVal oprot $ from_DeleteTodo_result record
to_DeleteTodo_result :: T.ThriftVal -> DeleteTodo_result
to_DeleteTodo_result (T.TStruct fields) = DeleteTodo_result{

  }
to_DeleteTodo_result _ = P.error "not a struct"
read_DeleteTodo_result :: T.Protocol p => p -> P.IO DeleteTodo_result
read_DeleteTodo_result iprot = to_DeleteTodo_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteTodo_result)
decode_DeleteTodo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteTodo_result
decode_DeleteTodo_result iprot bs = to_DeleteTodo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteTodo_result) bs
typemap_DeleteTodo_result :: T.TypeMap
typemap_DeleteTodo_result = Map.fromList []
default_DeleteTodo_result :: DeleteTodo_result
default_DeleteTodo_result = DeleteTodo_result{
}
data GetRelated_args = GetRelated_args  { getRelated_args_todo :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRelated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRelated_args_todo record  
instance QC.Arbitrary GetRelated_args where 
  arbitrary = M.liftM GetRelated_args (QC.arbitrary)
  shrink obj | obj == default_GetRelated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRelated_args{getRelated_args_todo = getRelated_args_todo obj} then P.Nothing else P.Just $ default_GetRelated_args{getRelated_args_todo = getRelated_args_todo obj}
    ]
from_GetRelated_args :: GetRelated_args -> T.ThriftVal
from_GetRelated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v63 -> P.Just (1, ("todo",T.TI32 _v63))) $ getRelated_args_todo record
  ]
write_GetRelated_args :: T.Protocol p => p -> GetRelated_args -> P.IO ()
write_GetRelated_args oprot record = T.writeVal oprot $ from_GetRelated_args record
encode_GetRelated_args :: T.StatelessProtocol p => p -> GetRelated_args -> LBS.ByteString
encode_GetRelated_args oprot record = T.serializeVal oprot $ from_GetRelated_args record
to_GetRelated_args :: T.ThriftVal -> GetRelated_args
to_GetRelated_args (T.TStruct fields) = GetRelated_args{
  getRelated_args_todo = P.maybe (getRelated_args_todo default_GetRelated_args) (\(_,_val65) -> (case _val65 of {T.TI32 _val66 -> _val66; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRelated_args _ = P.error "not a struct"
read_GetRelated_args :: T.Protocol p => p -> P.IO GetRelated_args
read_GetRelated_args iprot = to_GetRelated_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRelated_args)
decode_GetRelated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRelated_args
decode_GetRelated_args iprot bs = to_GetRelated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRelated_args) bs
typemap_GetRelated_args :: T.TypeMap
typemap_GetRelated_args = Map.fromList [(1,("todo",T.T_I32))]
default_GetRelated_args :: GetRelated_args
default_GetRelated_args = GetRelated_args{
  getRelated_args_todo = 0}
data GetRelated_result = GetRelated_result  { getRelated_result_success :: (Vector.Vector I.Int32)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRelated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRelated_result_success record  
instance QC.Arbitrary GetRelated_result where 
  arbitrary = M.liftM GetRelated_result (QC.arbitrary)
  shrink obj | obj == default_GetRelated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRelated_result{getRelated_result_success = getRelated_result_success obj} then P.Nothing else P.Just $ default_GetRelated_result{getRelated_result_success = getRelated_result_success obj}
    ]
from_GetRelated_result :: GetRelated_result -> T.ThriftVal
from_GetRelated_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v69 -> P.Just (0, ("success",T.TList T.T_I32 $ P.map (\_v71 -> T.TI32 _v71) $ Vector.toList _v69))) $ getRelated_result_success record
  ]
write_GetRelated_result :: T.Protocol p => p -> GetRelated_result -> P.IO ()
write_GetRelated_result oprot record = T.writeVal oprot $ from_GetRelated_result record
encode_GetRelated_result :: T.StatelessProtocol p => p -> GetRelated_result -> LBS.ByteString
encode_GetRelated_result oprot record = T.serializeVal oprot $ from_GetRelated_result record
to_GetRelated_result :: T.ThriftVal -> GetRelated_result
to_GetRelated_result (T.TStruct fields) = GetRelated_result{
  getRelated_result_success = P.maybe (getRelated_result_success default_GetRelated_result) (\(_,_val73) -> (case _val73 of {T.TList _ _val74 -> (Vector.fromList $ P.map (\_v75 -> (case _v75 of {T.TI32 _val76 -> _val76; _ -> P.error "wrong type"})) _val74); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetRelated_result _ = P.error "not a struct"
read_GetRelated_result :: T.Protocol p => p -> P.IO GetRelated_result
read_GetRelated_result iprot = to_GetRelated_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRelated_result)
decode_GetRelated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRelated_result
decode_GetRelated_result iprot bs = to_GetRelated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRelated_result) bs
typemap_GetRelated_result :: T.TypeMap
typemap_GetRelated_result = Map.fromList [(0,("success",(T.T_LIST T.T_I32)))]
default_GetRelated_result :: GetRelated_result
default_GetRelated_result = GetRelated_result{
  getRelated_result_success = Vector.empty}
process_createTodo (seqid, iprot, oprot, handler) = do
  args <- read_CreateTodo_args iprot
  (X.catch
    (do
      val <- Iface.createTodo handler (createTodo_args_title args)
      let res = default_CreateTodo_result{createTodo_result_success = val}
      T.writeMessage oprot ("createTodo", T.M_REPLY, seqid) $
        write_CreateTodo_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("createTodo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getTodo (seqid, iprot, oprot, handler) = do
  args <- read_GetTodo_args iprot
  (X.catch
    (do
      val <- Iface.getTodo handler (getTodo_args_id args)
      let res = default_GetTodo_result{getTodo_result_success = val}
      T.writeMessage oprot ("getTodo", T.M_REPLY, seqid) $
        write_GetTodo_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("getTodo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateTodo (seqid, iprot, oprot, handler) = do
  args <- read_UpdateTodo_args iprot
  (X.catch
    (do
      val <- Iface.updateTodo handler (updateTodo_args_todo args)
      let res = default_UpdateTodo_result{updateTodo_result_success = val}
      T.writeMessage oprot ("updateTodo", T.M_REPLY, seqid) $
        write_UpdateTodo_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("updateTodo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_deleteTodo (seqid, iprot, oprot, handler) = do
  args <- read_DeleteTodo_args iprot
  (X.catch
    (do
      Iface.deleteTodo handler (deleteTodo_args_todo args)
      let res = default_DeleteTodo_result
      T.writeMessage oprot ("deleteTodo", T.M_REPLY, seqid) $
        write_DeleteTodo_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("deleteTodo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRelated (seqid, iprot, oprot, handler) = do
  args <- read_GetRelated_args iprot
  (X.catch
    (do
      val <- Iface.getRelated handler (getRelated_args_todo args)
      let res = default_GetRelated_result{getRelated_result_success = val}
      T.writeMessage oprot ("getRelated", T.M_REPLY, seqid) $
        write_GetRelated_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("getRelated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "createTodo" -> process_createTodo (seqid,iprot,oprot,handler)
  "getTodo" -> process_getTodo (seqid,iprot,oprot,handler)
  "updateTodo" -> process_updateTodo (seqid,iprot,oprot,handler)
  "deleteTodo" -> process_deleteTodo (seqid,iprot,oprot,handler)
  "getRelated" -> process_getRelated (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
